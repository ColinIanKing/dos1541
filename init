.pag 'init'
;ram & rom test, i/o-data init
.ski 3
	* = $e040+$141
f7	=$38            ;fail states
f6	=f7-8
f5	=f6-8
f4	=f5-8
f3	=f4-8
f2	=f3-8
f1	=f2-8
dromts	ldx #0          ;test for drom
	lda #$55        ; test for $55
drt05	cmp $d000
	bne drt10
	dex
	bne drt05
drt10	rts
.skip
; reset entry on power on
init	cld
	sei
	ldx #$ff
	txs
	stx ieeedo      ;free data lines
	stx pbdd1
	lda #davo+eoio+rfdo
	sta pad2        ;free control lines
	lda #%00011111
	sta padd2       ;then set ddr
	lda #errled+actldb+actlda 
	sta pbd2
;lda #%00111000
	sta pbdd2
.skip
;zero page test
zptst	ldx #0
	txa
zpt10	ldy #$55        ;alternating bits
	sty 0,x
	dex
	bne zpt10
	tax
zpt20	lda #$aa
	asl 0,x
	eor 0,x
	sta 0,x
	bne zpbad
.skip
	dex
	bne zpt20
.skip
	jsr dromts
	bne eromck      ;not here, goto e-rom test
	jmp $d005       ;diagnostics hook
.skip
romtst	;rom check subroutine
;set ip as indir. pntr
	ldx #16         ;checksum returned in .a
	ldy #0
	tya
	clc
.ski
romt10	adc (ip)y
	iny
	bne romt10
.skip
	dex
	beq romt20
.skip
	inc ip+1
	bne romt10
.skip
romt20	rts
zpbad	lda #$ff
	sta 0,x
	bne zpbad
.skip
;e-rom check
eromck	lda #f6
	sta pbd2
	lda #$e0        ;e-rom
	sta ip+1
	lda #0
	sta ip
	jsr romtst
.ski
	cmp #0
	beq fromck      ;ok, goto f-rom test
.skip
bade
	sta $e000
	jmp bade
.skip
;f-rom check
fromck	lda #f5
	sta pbd2
	lda #$f0
	sta ip+1
	jsr romtst
	cmp #0
	beq diagok      ;ok, goto 4k test
.skip
badf	
	sta $f000
	jmp badf
.skip
diagok	lda #0
	sta pbd2
	lda pbd2        ;compute primary addr
	and #7
	ora #$48        ;talk address
	sta tlkadr
	eor #$60        ;listen address
	sta lsnadr
;init command channel
	lda #talker+lisner
	sta chnrdy+cmdchn
	lda #'0
	sta chndat+cmdchn
dskint	jsr inttab
	lda #$ff
	ldx #33
dskin1	sta lintab,x
	dex
	bpl dskin1
	lda #cmdrd
	sta lintab+30
	lda #cmdwrt
	sta lintab+31
	lda #$3f        ;lindx 0 to 5 free
	sta linuse
.skip
	lda #$0f
	sta bufnum+12
	lda #$10
	sta bufnum+14
	lda #$ff
	sta bufnum+13
	sta bufnum+15
	lda #$88
	sta chnrdy+cmdrd
	lda #$01
	sta chnrdy+cmdwrt
	lda #0
	sta bufuse
	lda #$e0
	sta bufuse+1
	jsr usrint      ;init user jmp
	lda #10         ;set up sector offset
	sta secinc
.skip
;allow atn to interrupt
	sta atnpe
.skip3
; idle loop, waiting for something to do
idle	lda cmdwat      ; test for pending command
	beq idle2       ; no command waiting
	lda #0
	sta cmdwat
	sei
	jsr parsxq      ; parse and xeq command
idle2	cli             ;test for drive running or openfile
	lda #29
	sta temp+3
	lda #0          ;if file open, turn on act led
	sta temp
	sta temp+1
filo1	ldx temp+3      ;look thru lintab
	lda lintab,x    ;for active file
	cmp #$ff
	beq filo2
	sta lindx
	jsr getact
	tax
	lda lstjob,x    ;determine which drv it is on
	and #1
	tax
	inc temp,x
filo2	dec temp+3      ;set flag indicating drv
	bpl filo1       ;has file open
tstfil	ldy #14         ;look thru job que for
fil5	lda jobs,y      ; for jobs still running
	bpl fil6
	and #1
	tax
	inc temp,x      ;set flag indicating drive
fil6	dey             ;is active
	bpl fil5
	lda pbd2
	and #255-actlda-actldb
	sta pbd2
	lda temp
	beq filo3
	lda pbd2        ;turn on led if drive flag 
	ora #actldb     ; if not 0
	sta pbd2
filo3	lda temp+1
	beq filo4
	lda pbd2
	ora #actlda
	sta pbd2
filo4	jmp idle2       ;back to top of lop
.end
